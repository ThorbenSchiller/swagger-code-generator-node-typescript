// tslint:disable
/* eslint-disable */
{{>licenseInfo}}
import url from "url";
import fetch, {Response, RequestInit} from "node-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "{{{basePath}}}".replace(/\/+$/, "");

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export interface FetchArgs {
    url: string;
    options: RequestInit;
}

export class BaseAPI {
    protected configuration!: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

function serialize(data: unknown, contentType?: string): string {
    return typeof data !== "string" || contentType === "application/json" ? JSON.stringify(data) : data;
}

/**
 * Verfies that the given parameter is not null or undefined.
 *
 */
function requireParameter(parameter: unknown, name: string, nickname: string): void {
    if (parameter === null || parameter === undefined) {
        throw new RequiredError(name, `Required parameter ${name} was null or undefined when calling ${nickname}.`);
    }
}

{{#models}}
{{#model}}{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{>modelGeneric}}{{/isEnum}}{{/model}}
{{/models}}
{{#apiInfo}}{{#apis}}{{#operations}}
/**
 * {{classname}} - fetch parameter creator{{#description}}
 * {{&description}}{{/description}}
 */
export const {{classname}}FetchParamCreator = function (configuration: Configuration = {}) {
    return {
    {{#operation}}
        /**
         * {{&notes}}
         *
         {{#allParams}}
         * @param {{paramName}} {{description}}
         {{/allParams}}
         * @param options Override http request option.
         * @throws RequiredError
         */
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options: RequestInit = {}): FetchArgs {
    {{#allParams}}
    {{#required}}
            requireParameter({{paramName}}, '{{paramName}}', '{{nickname}}');
    {{/required}}
    {{/allParams}}
            const localVarPath = "{{{path}}}"{{#pathParams}}
                .replace({{=<% %>=}}"{<% baseName %>}"<%={{ }}=%>, encodeURIComponent(String({{paramName}}))){{/pathParams}};
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = {
                ...(configuration.fetchOptions || {}),
                ...options,
                method: '{{httpMethod}}'
            };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
    {{#hasFormParams}}
            const localVarFormParams = new url.URLSearchParams();
    {{/hasFormParams}}

    {{#authMethods}}
            // authentication {{name}} required
            {{#isApiKey}}
            {{#isKeyInHeader}}
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("{{keyParamName}}")
					: configuration.apiKey;
                localVarHeaderParameter["{{keyParamName}}"] = localVarApiKeyValue;
            }
            {{/isKeyInHeader}}
            {{#isKeyInQuery}}
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("{{keyParamName}}")
					: configuration.apiKey;
                localVarQueryParameter["{{keyParamName}}"] = localVarApiKeyValue;
            }
            {{/isKeyInQuery}}
            {{/isApiKey}}
            {{#isBasic}}
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }
            {{/isBasic}}
            {{#isOAuth}}
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            {{/isOAuth}}

    {{/authMethods}}
    {{#queryParams}}
            {{#isListContainer}}
            if ({{paramName}}) {
            {{#isCollectionFormatMulti}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}};
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]);
            {{/isCollectionFormatMulti}}
            }
            {{/isListContainer}}
            {{^isListContainer}}
            if ({{paramName}} !== undefined) {
                {{#isDateTime}}
                localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any).toISOString();
                {{/isDateTime}}
                {{^isDateTime}}
                {{#isDate}}
                localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any).toISOString();
                {{/isDate}}
                {{^isDate}}
                localVarQueryParameter['{{baseName}}'] = {{paramName}};
                {{/isDate}}
                {{/isDateTime}}
            }
            {{/isListContainer}}

    {{/queryParams}}
    {{#headerParams}}
            {{#isListContainer}}
            if ({{paramName}}) {
                localVarHeaderParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
            }
            {{/isListContainer}}
            {{^isListContainer}}
            if ({{paramName}} !== undefined && {{paramName}} !== null) {
                localVarHeaderParameter['{{baseName}}'] = String({{paramName}});
            }
            {{/isListContainer}}
    {{/headerParams}}
    {{#formParams}}
            {{#isListContainer}}
            if ({{paramName}}) {
            {{#isCollectionFormatMulti}}
                {{paramName}}.forEach((element) => {
                    localVarFormParams.append('{{baseName}}', element as any);
                })
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
                    localVarFormParams.set('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
            {{/isCollectionFormatMulti}}
            }
            {{/isListContainer}}
            {{^isListContainer}}
            if ({{paramName}} !== undefined) {
                localVarFormParams.set('{{baseName}}', {{paramName}} as any);
            }
            {{/isListContainer}}

    {{/formParams}}
    {{#hasFormParams}}
            const contentType = 'application/x-www-form-urlencoded';
            localVarHeaderParameter['Content-Type'] = contentType;

    {{/hasFormParams}}
    {{#bodyParam}}
            const contentType = '{{^consumes}}application/json{{/consumes}}{{#consumes.0}}{{{mediaType}}}{{/consumes.0}}';
            localVarHeaderParameter['Content-Type'] = contentType;

    {{/bodyParam}}
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
    {{#hasFormParams}}
            localVarRequestOptions.body = localVarFormParams.toString();
    {{/hasFormParams}}
    {{#bodyParam}}
            localVarRequestOptions.body = serialize({{paramName}} || "", contentType);
    {{/bodyParam}}

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    {{/operation}}
    }
}

/**
 * {{classname}} - functional programming interface{{#description}}
 * {{{description}}}{{/description}}
 */
export const {{classname}}Fp = function(configuration?: Configuration) {
    return {
    {{#operation}}
        /**
         * {{&notes}}
         *
         {{#allParams}}
         * @param {{paramName}} {{description}}
         {{/allParams}}
         * @param options Override http request option.
         * @throws RequiredError
         */
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: RequestInit): (basePath?: string) => Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Response{{/returnType}}> {
            const localVarFetchArgs = {{classname}}FetchParamCreator(configuration).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options);
            return (basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response{{#returnType}}.json(){{/returnType}};
                    } else {
                        throw response;
                    }
                });
            };
        },
    {{/operation}}
    }
};

/**
 * {{classname}} - factory interface{{#description}}
 * {{&description}}{{/description}}
 */
export const {{classname}}Factory = function (configuration?: Configuration, basePath?: string) {
    return {
    {{#operation}}
        /**
         * {{&notes}}
         *
         {{#allParams}}
         * @param {{paramName}} {{description}}
         {{/allParams}}
         * @param options Override http request option.
         * @throws RequiredError
         */
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: RequestInit) {
            return {{classname}}Fp(configuration).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options)(basePath);
        },
    {{/operation}}
    };
};

{{#withInterfaces}}
/**
 * {{classname}} - interface{{#description}}
 * {{&description}}{{/description}}
 */
export interface {{classname}}Interface {
{{#operation}}
    /**
     * {{&notes}}
     *
     {{#allParams}}
     * @param {{paramName}} {{description}}
     {{/allParams}}
     * @param options Override http request option.
     * @throws RequiredError
     */
    {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: RequestInit): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}{}{{/returnType}}>;

{{/operation}}
}

{{/withInterfaces}}
/**
 * {{classname}} - object-oriented interface{{#description}}
 * {{{description}}}{{/description}}
 */
{{#withInterfaces}}
export class {{classname}} extends BaseAPI implements {{classname}}Interface {
{{/withInterfaces}}
{{^withInterfaces}}
export class {{classname}} extends BaseAPI {
{{/withInterfaces}}
    {{#operation}}
    /**
     * {{&notes}}
     *
     {{#allParams}}
     * @param {{paramName}} {{description}}
     {{/allParams}}
     * @param options Override http request option.
     * @throws RequiredError
     */
    public {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: RequestInit) {
        return {{classname}}Fp(this.configuration).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options)(this.basePath);
    }

    {{/operation}}
}
{{/operations}}{{/apis}}{{/apiInfo}}
